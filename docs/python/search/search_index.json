{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Apache OpenDAL\u2122 Python binding","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install opendal\n</code></pre>"},{"location":"#local-usage","title":"Local Usage","text":"<p>Developer must set two required arguments to work with files locally: - <code>scheme</code>: which should be specified as <code>fs</code> - <code>root</code>: where OpenDAl considers the root of the directory for operations will be.</p> <p>For example in the following operator: <code>opendal.Operator(\"fs\", root=\"/foo\")</code></p> <p>OpenDAL considers <code>/foo</code> to be the root of all paths, and that means that we can access paths inside of <code>/foo</code> without specifying anything else. If <code>/foo</code> happens to contain the file <code>baz.txt</code>, we can simply call <code>.list(\"/\")</code></p> <p>We can see this in the following example:</p> <pre><code>from opendal import Operator\nfrom pathlib import Path\nimport os\n\n\nos.makedirs(\"foo\", exist_ok=True)\n\nfile = Path(\"foo\", \"bar.txt\")\nfile.touch()\n\nop = Operator(\"fs\", root=Path(\"foo\").name)\nfor file in op.list(\"/\"):\n    print(file)\n</code></pre> <p>When running we get the following output:</p> <pre><code>/\nbar.txt\n</code></pre> <p>If we want full access to our file system, we can specify a root of <code>\"/\"</code>, but note that for any operations you will always need to specify the full path to a file or directory.</p>"},{"location":"#reading","title":"Reading","text":"<p>There are two ways to read data using OpenDAL. One way is to use the <code>read</code> method on an operator: <pre><code>from opendal import Operator\nfrom pathlib import Path\nimport os\n\n\nos.makedirs(\"foo\", exist_ok=True)\n\nfile = Path(\"foo\", \"bar.txt\")\nfile.touch()\nfile.write_text(\"baz\")\n\n\nop = Operator(\"fs\", root=Path(\"foo\").name)\n\ndata = op.read(file.name)\nprint(data)\n</code></pre></p> <p>Yields the following: <pre><code>b'baz'\n</code></pre></p> <p>Note that the output is bytes, but we can get it as a string by simply calling <code>.decode()</code> on the data we read. All reads with OpenDAL return bytes.</p> <p>Now lets use the <code>open</code> method on an operator: <pre><code>from opendal import Operator\nfrom pathlib import Path\nimport os\n\n\nos.makedirs(\"foo\", exist_ok=True)\n\nfile = Path(\"foo\", \"bar.txt\")\nfile.touch()\nfile.write_text(\"baz\")\n\n\nop = Operator(\"fs\", root=Path(\"foo\").name)\n\nwith op.open(file.name, \"rb\") as f:\n    print(f.read())\n</code></pre></p> <p>This again yields <pre><code>b'baz'\n</code></pre></p> <p>Again, note that all reads with OpenDAL return bytes, so specifying a mode of <code>\"r\"</code> will raise an exception.</p>"},{"location":"#writing","title":"Writing","text":"<p>Now that we know how to read data, let's replace the <code>Pathlib</code> code above with OpenDAL using the <code>write</code> method: <pre><code>from opendal import Operator\nfrom pathlib import Path\n\n\nop = Operator(\"fs\", root=Path(\"foo\").name)\n\nop.write(\"baz.txt\", \"my amazing data\".encode())\n\nprint(op.read(\"baz.txt\").decode())\n</code></pre></p> <p>This yields the following: <pre><code>my amazing data\n</code></pre></p> <p>And again, but using the <code>open</code> method: <pre><code>from opendal import Operator\nfrom pathlib import Path\n\n\nop = Operator(\"fs\", root=Path(\"foo\").name)\n\nwith op.open(\"baz.txt\", \"wb\") as f:\n    f.write(\"my amazing data\".encode())\n\nprint(op.read(\"baz.txt\").decode())\n</code></pre></p> <p>This again yields:</p> <pre><code>my amazing data\n</code></pre> <p>Again, note that all writing happens in bytes and a mode of <code>\"w\"</code> will raise an exception.</p>"},{"location":"#async","title":"Async","text":"<p>OpenDAL supports async operation on all operator methods. One can simply replace the <code>Operator</code> with an <code>AsyncOperator</code> and await on method calls. The below example illustrates this behavior:</p> <p>Standard API:</p> <pre><code>import opendal\n\nop = opendal.Operator(\"fs\", root=\"/tmp\")\nop.write(\"test.txt\", b\"Hello World\")\nprint(op.read(\"test.txt\"))\nprint(op.stat(\"test.txt\").content_length)\n</code></pre> <p>Async API equivalent:</p> <pre><code>import asyncio\n\nasync def main():\n    op = opendal.AsyncOperator(\"fs\", root=\"/tmp\")\n    await op.write(\"test.txt\", b\"Hello World\")\n    print(await op.read(\"test.txt\"))\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/async_file/","title":"AsyncFile","text":"<p>A file-like object for reading and writing data.</p> <p>Created by the <code>open</code> method of the <code>AsyncOperator</code> class.</p>"},{"location":"api/async_file/#opendal.AsyncFile.closed","title":"<code>closed</code>  <code>async</code> <code>property</code>","text":"<p>Check if the file is closed.</p>"},{"location":"api/async_file/#opendal.AsyncFile.__aenter__","title":"<code>__aenter__()</code>","text":"<p>Enter the runtime context related to this object.</p>"},{"location":"api/async_file/#opendal.AsyncFile.__aexit__","title":"<code>__aexit__(exc_type, exc_value, traceback)</code>","text":"<p>Exit the runtime context related to this object.</p>"},{"location":"api/async_file/#opendal.AsyncFile.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the file.</p>"},{"location":"api/async_file/#opendal.AsyncFile.read","title":"<code>read(size=None)</code>  <code>async</code>","text":"<p>Read the content of the file.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The number of bytes to read. If None, read all.</p> <code>None</code>"},{"location":"api/async_file/#opendal.AsyncFile.read--returns","title":"Returns","text":"<pre><code>The content of the file as bytes.\n</code></pre>"},{"location":"api/async_file/#opendal.AsyncFile.readable","title":"<code>readable()</code>  <code>async</code>","text":"<p>Check if the file is readable.</p>"},{"location":"api/async_file/#opendal.AsyncFile.seek","title":"<code>seek(pos, whence=0)</code>  <code>async</code>","text":"<p>Set the file's current position.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>int</code> <p>The position to set.</p> required <code>whence</code> <code>int</code> <p>The reference point for the position. Can be 0, 1, or 2.</p> <code>0</code>"},{"location":"api/async_file/#opendal.AsyncFile.seek--returns","title":"Returns","text":"<pre><code>The new position in the file.\n</code></pre>"},{"location":"api/async_file/#opendal.AsyncFile.seekable","title":"<code>seekable()</code>  <code>async</code>","text":"<p>Check if the file supports seeking.</p>"},{"location":"api/async_file/#opendal.AsyncFile.tell","title":"<code>tell()</code>  <code>async</code>","text":"<p>Get the current position in the file.</p>"},{"location":"api/async_file/#opendal.AsyncFile.tell--returns","title":"Returns","text":"<pre><code>The current position in the file.\n</code></pre>"},{"location":"api/async_file/#opendal.AsyncFile.writable","title":"<code>writable()</code>  <code>async</code>","text":"<p>Check if the file is writable.</p>"},{"location":"api/async_file/#opendal.AsyncFile.write","title":"<code>write(bs)</code>  <code>async</code>","text":"<p>Write the content to the file.</p> <p>Parameters:</p> Name Type Description Default <code>bs</code> <code>bytes</code> <p>The content to write.</p> required"},{"location":"api/async_operator/","title":"AsyncOperator","text":"<p>The entry class for all public async APIs.</p> <p>Parameters:</p> Name Type Description Default <code>scheme</code> <code>str</code> <p>The service name that OpenDAL supports.</p> required <code>**options</code> <code>any</code> <p>The options for the service. See the documentation of each service for more details.</p> <code>{}</code> Example <pre><code>import opendal\n\nop = opendal.AsyncOperator(\n    \"s3\", bucket=\"bucket\", region=\"us-east-1\"\n)\nawait op.write(\"hello.txt\", b\"hello world\")\n</code></pre>"},{"location":"api/async_operator/#opendal.AsyncOperator.copy","title":"<code>copy(source, target)</code>  <code>async</code>","text":"<p>Copy the object from source to target.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | Path</code> <p>The source path.</p> required <code>target</code> <code>str | Path</code> <p>The target path.</p> required"},{"location":"api/async_operator/#opendal.AsyncOperator.create_dir","title":"<code>create_dir(path)</code>  <code>async</code>","text":"<p>Create a directory at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the directory.</p> required"},{"location":"api/async_operator/#opendal.AsyncOperator.delete","title":"<code>delete(path)</code>  <code>async</code>","text":"<p>Delete the object at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required"},{"location":"api/async_operator/#opendal.AsyncOperator.exists","title":"<code>exists(path)</code>  <code>async</code>","text":"<p>Check if the object at the given path exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required"},{"location":"api/async_operator/#opendal.AsyncOperator.exists--returns","title":"Returns","text":"<pre><code>True if the object exists, False otherwise.\n</code></pre>"},{"location":"api/async_operator/#opendal.AsyncOperator.list","title":"<code>list(path, **kwargs)</code>  <code>async</code>","text":"<p>List objects at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the directory/ prefix.</p> required <code>**kwargs</code> <code>Any</code> <p>Optional listing parameters matching the OpenDAL <code>ListOptions</code>:</p> <ul> <li>limit (int): The limit passed to the underlying service to specify the     max results that could return per-request. Users could use this to     control the memory usage of list operation. If not set, all matching     entries will be listed.</li> <li>start_after (str): Start listing after this key. Useful for pagination     or resuming interrupted listings.</li> <li>recursive (bool): Whether to list entries recursively through all     subdirectories. If False, lists only top-level entries (entries     under the given path).</li> <li>versions (bool): Whether to include all versions of objects, if the     underlying service supports versioning.</li> <li>deleted (bool): Whether to include deleted objects, if the underlying     service supports soft-deletes or versioning.</li> </ul> <code>{}</code>"},{"location":"api/async_operator/#opendal.AsyncOperator.list--returns","title":"Returns","text":"<pre><code>Iterable[Entry]: An iterable of entries representing the objects in the\n    directory or prefix.\n</code></pre>"},{"location":"api/async_operator/#opendal.AsyncOperator.open","title":"<code>open(path, mode, **options)</code>  <code>async</code>","text":"<p>Open a file at the given path for reading or writing.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the file.</p> required <code>mode</code> <code>str</code> <p>The mode to open the file. Must be either <code>\"rb\"</code> for reading or <code>\"wb\"</code> for writing.</p> required <code>**options</code> <code>Any</code> <p>Additional options passed to the underlying OpenDAL reader or writer. - If <code>mode == \"rb\"</code>: options match the   OpenDAL <code>ReaderOptions</code>. - If <code>mode == \"wb\"</code>: options match the   OpenDAL <code>WriteOptions</code>.</p> <code>{}</code>"},{"location":"api/async_operator/#opendal.AsyncOperator.open--returns","title":"Returns","text":"<pre><code>AsyncFile: A file-like object that can be used to read or write the file.\n</code></pre> Example <pre><code>import opendal\n\nop = opendal.AsyncOperator(\n    \"s3\", bucket=\"bucket\", region=\"us-east-1\"\n)\nasync with await op.open(\"hello.txt\", \"wb\") as f:\n    await f.write(b\"hello world\")\n</code></pre>"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_delete","title":"<code>presign_delete(path, expire_second)</code>  <code>async</code>","text":"<p>Generate a presigned URL for delete operation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required <code>expire_second</code> <code>int</code> <p>The expiration time in seconds.</p> required"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_delete--returns","title":"Returns","text":"<pre><code>A presigned request object.\n</code></pre>"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_read","title":"<code>presign_read(path, expire_second)</code>  <code>async</code>","text":"<p>Generate a presigned URL for read operation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required <code>expire_second</code> <code>int</code> <p>The expiration time in seconds.</p> required"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_read--returns","title":"Returns","text":"<pre><code>A presigned request object.\n</code></pre>"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_stat","title":"<code>presign_stat(path, expire_second)</code>  <code>async</code>","text":"<p>Generate a presigned URL for stat operation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required <code>expire_second</code> <code>int</code> <p>The expiration time in seconds.</p> required"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_stat--returns","title":"Returns","text":"<pre><code>A presigned request object.\n</code></pre>"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_write","title":"<code>presign_write(path, expire_second)</code>  <code>async</code>","text":"<p>Generate a presigned URL for write operation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required <code>expire_second</code> <code>int</code> <p>The expiration time in seconds.</p> required"},{"location":"api/async_operator/#opendal.AsyncOperator.presign_write--returns","title":"Returns","text":"<pre><code>A presigned request object.\n</code></pre>"},{"location":"api/async_operator/#opendal.AsyncOperator.read","title":"<code>read(path, **options)</code>  <code>async</code>","text":"<p>Read the content of the object at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required <code>**options</code> <code>Any</code> <p>Optional read parameters matching the OpenDAL <code>ReadOptions</code>:</p> <ul> <li>offset (int): Byte offset to start reading from. Defaults to 0     if not specified.</li> <li>size (int): Number of bytes to read. If not specified, reads until     the end of the object.   Together, <code>offset</code> and <code>size</code> define the byte range for reading.</li> <li>version (str): Specify the version of the object to read, if     supported by the backend.</li> <li>concurrent (int): Level of concurrency for reading. Defaults to     backend-specific value.</li> <li>chunk (int): Read chunk size in bytes.</li> <li>gap (int): Minimum gap (in bytes) between chunks to consider     them separate.</li> <li>override_content_type (str): Override the returned content type.</li> <li>if_match (str): Read only if the ETag matches the given value.</li> <li>if_none_match (str): Read-only if the ETag does not match the     given value.</li> <li>if_modified_since (datetime): Only read if the object was modified     since this timestamp. This timestamp must be in UTC.</li> <li>if_unmodified_since (datetime): Only read if the object was not     modified since this timestamp. This timestamp must be in UTC.</li> </ul> <code>{}</code>"},{"location":"api/async_operator/#opendal.AsyncOperator.read--returns","title":"Returns","text":"<pre><code>The content of the object as bytes.\n</code></pre>"},{"location":"api/async_operator/#opendal.AsyncOperator.remove_all","title":"<code>remove_all(path)</code>  <code>async</code>","text":"<p>Remove all objects at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the directory.</p> required"},{"location":"api/async_operator/#opendal.AsyncOperator.rename","title":"<code>rename(source, target)</code>  <code>async</code>","text":"<p>Rename the object from source to target.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | Path</code> <p>The source path.</p> required <code>target</code> <code>str | Path</code> <p>The target path.</p> required"},{"location":"api/async_operator/#opendal.AsyncOperator.scan","title":"<code>scan(path, **kwargs)</code>  <code>async</code>","text":"<p>Scan the objects at the given path recursively.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the directory/ prefix.</p> required <code>**kwargs</code> <code>Any</code> <p>Optional listing parameters matching the OpenDAL <code>ListOptions</code>, excluding <code>recursive</code> which is always enforced as <code>True</code></p> <code>{}</code>"},{"location":"api/async_operator/#opendal.AsyncOperator.scan--returns","title":"Returns","text":"<pre><code>Iterable[Entry]: An iterable of all entries under the given path,\n    recursively traversing all subdirectories. Each entry represents\n    an object (e.g., file or directory) discovered within the full\n    descendant hierarchy of the specified path.\n</code></pre>"},{"location":"api/async_operator/#opendal.AsyncOperator.stat","title":"<code>stat(path, **kwargs)</code>  <code>async</code>","text":"<p>Get the metadata of the object at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required <code>**kwargs</code> <code>Any</code> <p>Optional stat parameters matching the OpenDAL <code>StatOptions</code>:</p> <ul> <li>version (str): Specify the version of the object to read, if     supported by the backend.</li> <li>if_match (str): Read only if the ETag matches the given value.</li> <li>if_none_match (str): Read-only if the ETag does not match the     given value.</li> <li>if_modified_since (datetime): Only read if the object was modified     since this timestamp. This timestamp must be in UTC.</li> <li>if_unmodified_since (datetime): Only read if the object was not     modified since this timestamp. This timestamp must be in UTC.</li> <li>cache_control (str): Override the cache-control header for the object.</li> <li>content_type (str): Explicitly set the Content-Type header for     the object.</li> <li>content_disposition (str): Sets how the object should be presented     (e.g., as an attachment).</li> </ul> <code>{}</code>"},{"location":"api/async_operator/#opendal.AsyncOperator.stat--returns","title":"Returns","text":"<pre><code>Metadata: The metadata of the object.\n</code></pre>"},{"location":"api/async_operator/#opendal.AsyncOperator.write","title":"<code>write(path, bs, **options)</code>  <code>async</code>","text":"<p>Write the content to the object at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required <code>bs</code> <code>bytes</code> <p>The content to write.</p> required <code>**options</code> <code>Any</code> <p>Optional write parameters matching the OpenDAL <code>WriteOptions</code>:</p> <ul> <li>append (bool): If True, append to the object instead of overwriting.</li> <li>chunk (int): Specify the chunk size in bytes for multipart uploads.</li> <li>concurrent (int): Number of concurrent upload parts. Larger values can     improve performance.</li> <li>cache_control (str): Override the cache-control header for the object.</li> <li>content_type (str): Explicitly set the Content-Type header for     the object.</li> <li>content_disposition (str): Sets how the object should be presented     (e.g., as an attachment).</li> <li>content_encoding (str): Override the Content-Encoding header.</li> <li>if_match (str): Perform the write only if the object's current     ETag matches the given one.</li> <li>if_none_match (str): Perform the write only if the object's     current ETag does NOT match the given one.</li> <li>if_not_exists (bool): Only write the object if it doesn't     already exist.</li> <li>user_metadata (dict[str, str]): Custom user metadata to associate     with the object.</li> </ul> <code>{}</code>"},{"location":"api/async_operator/#opendal.AsyncOperator.write--returns","title":"Returns","text":"<pre><code>None\n</code></pre>"},{"location":"api/capability/","title":"Capability","text":"<p>Capability defines the supported operations and their constraints for an Operator.</p> <p>This structure provides a comprehensive description of an Operator's capabilities, including:</p> <ul> <li>Basic operations support (read, write, delete, etc.)</li> <li>Advanced operation variants (conditional operations, metadata handling)</li> <li>Operational constraints (size limits, batch limitations)</li> </ul>"},{"location":"api/capability/#opendal.Capability.copy","title":"<code>copy</code>  <code>property</code>","text":"<p>If operator supports copy.</p>"},{"location":"api/capability/#opendal.Capability.create_dir","title":"<code>create_dir</code>  <code>property</code>","text":"<p>If operator supports create dir.</p>"},{"location":"api/capability/#opendal.Capability.delete","title":"<code>delete</code>  <code>property</code>","text":"<p>If operator supports delete.</p>"},{"location":"api/capability/#opendal.Capability.list","title":"<code>list</code>  <code>property</code>","text":"<p>If operator supports list.</p>"},{"location":"api/capability/#opendal.Capability.list_with_limit","title":"<code>list_with_limit</code>  <code>property</code>","text":"<p>If backend supports list with limit.</p>"},{"location":"api/capability/#opendal.Capability.list_with_recursive","title":"<code>list_with_recursive</code>  <code>property</code>","text":"<p>If backend supports list without delimiter.</p>"},{"location":"api/capability/#opendal.Capability.list_with_start_after","title":"<code>list_with_start_after</code>  <code>property</code>","text":"<p>If backend supports list with start after.</p>"},{"location":"api/capability/#opendal.Capability.presign","title":"<code>presign</code>  <code>property</code>","text":"<p>If operator supports presign.</p>"},{"location":"api/capability/#opendal.Capability.presign_delete","title":"<code>presign_delete</code>  <code>property</code>","text":"<p>If operator supports presign delete.</p>"},{"location":"api/capability/#opendal.Capability.presign_read","title":"<code>presign_read</code>  <code>property</code>","text":"<p>If operator supports presign read.</p>"},{"location":"api/capability/#opendal.Capability.presign_stat","title":"<code>presign_stat</code>  <code>property</code>","text":"<p>If operator supports presign stat.</p>"},{"location":"api/capability/#opendal.Capability.presign_write","title":"<code>presign_write</code>  <code>property</code>","text":"<p>If operator supports presign write.</p>"},{"location":"api/capability/#opendal.Capability.read","title":"<code>read</code>  <code>property</code>","text":"<p>If the operator supports read operations.</p>"},{"location":"api/capability/#opendal.Capability.read_with_if_match","title":"<code>read_with_if_match</code>  <code>property</code>","text":"<p>If conditional read operations using If-Match are supported.</p>"},{"location":"api/capability/#opendal.Capability.read_with_if_modified_since","title":"<code>read_with_if_modified_since</code>  <code>property</code>","text":"<p>If conditional read operations using If-Modified-Since are supported.</p>"},{"location":"api/capability/#opendal.Capability.read_with_if_none_match","title":"<code>read_with_if_none_match</code>  <code>property</code>","text":"<p>If conditional read operations using If-None-Match are supported.</p>"},{"location":"api/capability/#opendal.Capability.read_with_if_unmodified_since","title":"<code>read_with_if_unmodified_since</code>  <code>property</code>","text":"<p>If conditional read operations using If-Unmodified-Since are supported.</p>"},{"location":"api/capability/#opendal.Capability.read_with_override_cache_control","title":"<code>read_with_override_cache_control</code>  <code>property</code>","text":"<p>If Cache-Control header override is supported during read operations.</p>"},{"location":"api/capability/#opendal.Capability.read_with_override_content_disposition","title":"<code>read_with_override_content_disposition</code>  <code>property</code>","text":"<p>If Content-Disposition header can be overridden during read operations.</p>"},{"location":"api/capability/#opendal.Capability.read_with_override_content_type","title":"<code>read_with_override_content_type</code>  <code>property</code>","text":"<p>If Content-Type header override is supported during read operations.</p>"},{"location":"api/capability/#opendal.Capability.read_with_version","title":"<code>read_with_version</code>  <code>property</code>","text":"<p>If versions read operations are supported.</p>"},{"location":"api/capability/#opendal.Capability.rename","title":"<code>rename</code>  <code>property</code>","text":"<p>If operator supports rename.</p>"},{"location":"api/capability/#opendal.Capability.shared","title":"<code>shared</code>  <code>property</code>","text":"<p>If operator supports shared.</p>"},{"location":"api/capability/#opendal.Capability.stat","title":"<code>stat</code>  <code>property</code>","text":"<p>If operator supports stat.</p>"},{"location":"api/capability/#opendal.Capability.stat_with_if_match","title":"<code>stat_with_if_match</code>  <code>property</code>","text":"<p>If operator supports stat with if match.</p>"},{"location":"api/capability/#opendal.Capability.stat_with_if_none_match","title":"<code>stat_with_if_none_match</code>  <code>property</code>","text":"<p>If operator supports stat with if none match.</p>"},{"location":"api/capability/#opendal.Capability.write","title":"<code>write</code>  <code>property</code>","text":"<p>If the operator supports write operations.</p>"},{"location":"api/capability/#opendal.Capability.write_can_append","title":"<code>write_can_append</code>  <code>property</code>","text":"<p>If append operations are supported.</p>"},{"location":"api/capability/#opendal.Capability.write_can_empty","title":"<code>write_can_empty</code>  <code>property</code>","text":"<p>If writing empty content is supported.</p>"},{"location":"api/capability/#opendal.Capability.write_can_multi","title":"<code>write_can_multi</code>  <code>property</code>","text":"<p>If multiple write operations can be performed on the same object.</p>"},{"location":"api/capability/#opendal.Capability.write_multi_max_size","title":"<code>write_multi_max_size</code>  <code>property</code>","text":"<p>Maximum size supported for multipart uploads.</p> <p>For example, AWS S3 supports up to 5GiB per part in multipart uploads.</p>"},{"location":"api/capability/#opendal.Capability.write_multi_min_size","title":"<code>write_multi_min_size</code>  <code>property</code>","text":"<p>Minimum size required for multipart uploads (except for the last part).</p> <p>For example, AWS S3 requires at least 5MiB per part.</p>"},{"location":"api/capability/#opendal.Capability.write_total_max_size","title":"<code>write_total_max_size</code>  <code>property</code>","text":"<p>Maximum total size supported for write operations.</p> <p>For example, Cloudflare D1 has a 1MB total size limit.</p>"},{"location":"api/capability/#opendal.Capability.write_with_cache_control","title":"<code>write_with_cache_control</code>  <code>property</code>","text":"<p>If Cache-Control can be specified during write operations.</p>"},{"location":"api/capability/#opendal.Capability.write_with_content_disposition","title":"<code>write_with_content_disposition</code>  <code>property</code>","text":"<p>If Content-Disposition can be specified during write operations.</p>"},{"location":"api/capability/#opendal.Capability.write_with_content_encoding","title":"<code>write_with_content_encoding</code>  <code>property</code>","text":"<p>If Content-Encoding can be specified during write operations.</p>"},{"location":"api/capability/#opendal.Capability.write_with_content_type","title":"<code>write_with_content_type</code>  <code>property</code>","text":"<p>If Content-Type can be specified during write operations.</p>"},{"location":"api/capability/#opendal.Capability.write_with_if_match","title":"<code>write_with_if_match</code>  <code>property</code>","text":"<p>If conditional write operations using If-Match are supported.</p>"},{"location":"api/capability/#opendal.Capability.write_with_if_none_match","title":"<code>write_with_if_none_match</code>  <code>property</code>","text":"<p>If conditional write operations using If-None-Match are supported.</p>"},{"location":"api/capability/#opendal.Capability.write_with_if_not_exists","title":"<code>write_with_if_not_exists</code>  <code>property</code>","text":"<p>If write operations can be conditional on object non-existence.</p>"},{"location":"api/capability/#opendal.Capability.write_with_user_metadata","title":"<code>write_with_user_metadata</code>  <code>property</code>","text":"<p>If custom user metadata can be attached during write operations.</p>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>This page documents all exceptions raised by the OpenDAL.</p> <p>               Bases: <code>Exception</code></p> <p>OpenDAL Base Exception.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class Error(builtins.Exception):\n    r\"\"\"OpenDAL Base Exception.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Already exists.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class AlreadyExists(builtins.Exception):\n    r\"\"\"Already exists.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Condition not match.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class ConditionNotMatch(builtins.Exception):\n    r\"\"\"Condition not match.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Config is invalid.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class ConfigInvalid(builtins.Exception):\n    r\"\"\"Config is invalid.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Is a directory.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class IsADirectory(builtins.Exception):\n    r\"\"\"Is a directory.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Is same file.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class IsSameFile(builtins.Exception):\n    r\"\"\"Is same file.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Not a directory.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class NotADirectory(builtins.Exception):\n    r\"\"\"Not a directory.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Not found.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class NotFound(builtins.Exception):\n    r\"\"\"Not found.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Permission denied.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class PermissionDenied(builtins.Exception):\n    r\"\"\"Permission denied.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Unexpected errors.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class Unexpected(builtins.Exception):\n    r\"\"\"Unexpected errors.\"\"\"\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Unsupported operation.</p> Source code in <code>python/opendal/exceptions.pyi</code> <pre><code>class Unsupported(builtins.Exception):\n    r\"\"\"Unsupported operation.\"\"\"\n</code></pre>"},{"location":"api/file/","title":"File","text":"<p>A file-like object for reading and writing data.</p> <p>Created by the <code>open</code> method of the <code>Operator</code> class.</p>"},{"location":"api/file/#opendal.File.closed","title":"<code>closed</code>  <code>property</code>","text":"<p>Check if the file is closed.</p>"},{"location":"api/file/#opendal.File.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the runtime context related to this object.</p>"},{"location":"api/file/#opendal.File.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Exit the runtime context related to this object.</p>"},{"location":"api/file/#opendal.File.close","title":"<code>close()</code>","text":"<p>Close the file.</p>"},{"location":"api/file/#opendal.File.flush","title":"<code>flush()</code>","text":"<p>Flush the internal buffer.</p>"},{"location":"api/file/#opendal.File.read","title":"<code>read(size=None)</code>","text":"<p>Read the content of the file.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The number of bytes to read. If None, read all.</p> <code>None</code>"},{"location":"api/file/#opendal.File.read--returns","title":"Returns","text":"<pre><code>The content of the file as bytes.\n</code></pre>"},{"location":"api/file/#opendal.File.readable","title":"<code>readable()</code>","text":"<p>Check if the file is readable.</p>"},{"location":"api/file/#opendal.File.readinto","title":"<code>readinto(buffer)</code>","text":"<p>Read bytes into a buffer.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>bytes | bytearray</code> <p>The buffer to read into.</p> required"},{"location":"api/file/#opendal.File.readinto--returns","title":"Returns","text":"<pre><code>The number of bytes read.\n</code></pre>"},{"location":"api/file/#opendal.File.readline","title":"<code>readline(size=None)</code>","text":"<p>Read a single line from the file.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The number of bytes to read. If None, read until newline.</p> <code>None</code>"},{"location":"api/file/#opendal.File.readline--returns","title":"Returns","text":"<pre><code>The line read from the file as bytes.\n</code></pre>"},{"location":"api/file/#opendal.File.seek","title":"<code>seek(pos, whence=0)</code>","text":"<p>Set the file's current position.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>int</code> <p>The position to set.</p> required <code>whence</code> <code>int</code> <p>The reference point for the position. Can be 0, 1, or 2.</p> <code>0</code>"},{"location":"api/file/#opendal.File.seek--returns","title":"Returns","text":"<pre><code>The new position in the file.\n</code></pre>"},{"location":"api/file/#opendal.File.seekable","title":"<code>seekable()</code>","text":"<p>Check if the file supports seeking.</p>"},{"location":"api/file/#opendal.File.tell","title":"<code>tell()</code>","text":"<p>Get the current position in the file.</p>"},{"location":"api/file/#opendal.File.tell--returns","title":"Returns","text":"<pre><code>The current position in the file.\n</code></pre>"},{"location":"api/file/#opendal.File.writable","title":"<code>writable()</code>","text":"<p>Check if the file is writable.</p>"},{"location":"api/file/#opendal.File.write","title":"<code>write(bs)</code>","text":"<p>Write the content to the file.</p> <p>Parameters:</p> Name Type Description Default <code>bs</code> <code>bytes</code> <p>The content to write.</p> required"},{"location":"api/layers/","title":"Layers","text":"<p>This page documents all layers in OpenDAL.</p>"},{"location":"api/layers/#layer","title":"Layer","text":"<p>Layer.</p> <p>Layers are used to intercept the operations on the underlying storage.</p>"},{"location":"api/layers/#retrylayer","title":"RetryLayer","text":"<p>               Bases: <code>Layer</code></p> <p>RetryLayer.</p> <p>A layer that retries operations that fail with temporary errors.</p> <p>Operations are retried if they fail with an error for which <code>Error.is_temporary</code> returns <code>True</code>. If all retries are exhausted, the error is marked as persistent and then returned.</p>"},{"location":"api/layers/#opendal.layers.RetryLayer--notes","title":"Notes","text":"<p>After an operation on a <code>Reader</code> or <code>Writer</code> has failed through all retries, the object is in an undefined state. Reusing it can lead to exceptions.</p>"},{"location":"api/layers/#opendal.layers.RetryLayer.__new__","title":"<code>__new__(max_times=None, factor=None, jitter=False, max_delay=None, min_delay=None)</code>","text":"<p>Create a new RetryLayer.</p>"},{"location":"api/layers/#opendal.layers.RetryLayer.__new__--parameters","title":"Parameters","text":"<p>max_times : Optional[int]     Maximum number of retry attempts. Defaults to <code>3</code>. factor : Optional[float]     Backoff factor applied between retries. Defaults to <code>2.0</code>. jitter : bool     Whether to apply jitter to the backoff. Defaults to <code>False</code>. max_delay : Optional[float]     Maximum delay (in seconds) between retries. Defaults to <code>60.0</code>. min_delay : Optional[float]     Minimum delay (in seconds) between retries. Defaults to <code>1.0</code>.</p>"},{"location":"api/layers/#opendal.layers.RetryLayer.__new__--returns","title":"Returns","text":"<p>RetryLayer</p>"},{"location":"api/layers/#concurrentlimitlayer","title":"ConcurrentLimitLayer","text":"<p>               Bases: <code>Layer</code></p> <p>ConcurrentLimitLayer.</p> <p>Create a layer that limits the number of concurrent operations.</p>"},{"location":"api/layers/#opendal.layers.ConcurrentLimitLayer--notes","title":"Notes","text":"<p>All operators wrapped by this layer will share a common semaphore. This allows you to reuse the same layer across multiple operators, ensuring that the total number of concurrent requests across the entire application does not exceed the limit.</p>"},{"location":"api/layers/#opendal.layers.ConcurrentLimitLayer.__new__","title":"<code>__new__(limit)</code>","text":"<p>Create a new ConcurrentLimitLayer.</p>"},{"location":"api/layers/#opendal.layers.ConcurrentLimitLayer.__new__--parameters","title":"Parameters","text":"<p>limit : int     Maximum number of concurrent operations allowed.</p>"},{"location":"api/layers/#opendal.layers.ConcurrentLimitLayer.__new__--returns","title":"Returns","text":"<p>ConcurrentLimitLayer</p>"},{"location":"api/layers/#mimeguesslayer","title":"MimeGuessLayer","text":"<p>               Bases: <code>Layer</code></p> <p>MimeGuessLayer.</p> <p>Create a layer that guesses MIME types for objects based on their paths or content.</p> <p>This layer uses the <code>mime_guess</code> crate (see https://crates.io/crates/mime_guess) to infer the <code>Content-Type</code>.</p>"},{"location":"api/layers/#opendal.layers.MimeGuessLayer--notes","title":"Notes","text":"<p>This layer will not override a <code>Content-Type</code> that has already been set, either manually or by the backend service. It is only applied if no content type is present.</p> <p>A <code>Content-Type</code> is not guaranteed. If the file extension is uncommon or unknown, the content type will remain unset.</p>"},{"location":"api/layers/#opendal.layers.MimeGuessLayer.__new__","title":"<code>__new__()</code>","text":"<p>Create a new MimeGuessLayer.</p>"},{"location":"api/layers/#opendal.layers.MimeGuessLayer.__new__--returns","title":"Returns","text":"<p>MimeGuessLayer</p>"},{"location":"api/operator/","title":"Operator","text":"<p>The entry class for all public blocking APIs.</p> <p>Parameters:</p> Name Type Description Default <code>scheme</code> <code>str</code> <p>The service name that OpenDAL supports.</p> required <code>**options</code> <code>any</code> <p>The options for the service. See the documentation of each service for more details.</p> <code>{}</code> Example <pre><code>import opendal\n\nop = opendal.Operator(\n    \"s3\", bucket=\"bucket\", region=\"us-east-1\"\n)\nop.write(\"hello.txt\", b\"hello world\")\n</code></pre>"},{"location":"api/operator/#opendal.Operator.capability","title":"<code>capability()</code>","text":"<p>Get the capability of the operator.</p>"},{"location":"api/operator/#opendal.Operator.capability--returns","title":"Returns","text":"<pre><code>The capability of the operator.\n</code></pre>"},{"location":"api/operator/#opendal.Operator.copy","title":"<code>copy(source, target)</code>","text":"<p>Copy the object from source to target.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | Path</code> <p>The source path.</p> required <code>target</code> <code>str | Path</code> <p>The target path.</p> required"},{"location":"api/operator/#opendal.Operator.create_dir","title":"<code>create_dir(path)</code>","text":"<p>Create a directory at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the directory.</p> required"},{"location":"api/operator/#opendal.Operator.delete","title":"<code>delete(path)</code>","text":"<p>Delete the object at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required"},{"location":"api/operator/#opendal.Operator.exists","title":"<code>exists(path)</code>","text":"<p>Check if the object at the given path exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required"},{"location":"api/operator/#opendal.Operator.exists--returns","title":"Returns","text":"<pre><code>True if the object exists, False otherwise.\n</code></pre>"},{"location":"api/operator/#opendal.Operator.layer","title":"<code>layer(layer)</code>","text":"<p>Add new layers upon the current operator.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The layer to be added.</p> required"},{"location":"api/operator/#opendal.Operator.layer--returns","title":"Returns","text":"<pre><code>The new operator with the layer added.\n</code></pre>"},{"location":"api/operator/#opendal.Operator.list","title":"<code>list(path, **kwargs)</code>","text":"<p>List objects at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the directory/ prefix.</p> required <code>**kwargs</code> <code>Any</code> <p>Optional listing parameters matching the OpenDAL <code>ListOptions</code>:</p> <ul> <li>limit (int): The limit passed to the underlying service to specify the     max results that could return per-request. Users could use this to     control the memory usage of list operation. If not set, all matching     entries will be listed.</li> <li>start_after (str): Start listing after this key. Useful for pagination     or resuming interrupted listings.</li> <li>recursive (bool): Whether to list entries recursively through all     subdirectories. If False, lists only top-level entries (entries     under the given path).</li> <li>versions (bool): Whether to include all versions of objects, if the     underlying service supports versioning.</li> <li>deleted (bool): Whether to include deleted objects, if the underlying     service supports soft-deletes or versioning.</li> </ul> <code>{}</code>"},{"location":"api/operator/#opendal.Operator.list--returns","title":"Returns","text":"<pre><code>Iterable[Entry]: An iterable of entries representing the objects in the\n    directory or prefix.\n</code></pre>"},{"location":"api/operator/#opendal.Operator.open","title":"<code>open(path, mode, **options)</code>","text":"<p>Open a file at the given path for reading or writing.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the file.</p> required <code>mode</code> <code>str</code> <p>The mode to open the file. Must be either <code>\"rb\"</code> for reading or <code>\"wb\"</code> for writing.</p> required <code>**options</code> <code>Any</code> <p>Additional options passed to the underlying OpenDAL reader or writer. - If <code>mode == \"rb\"</code>: options match the   OpenDAL <code>ReaderOptions</code>. - If <code>mode == \"wb\"</code>: options match the   OpenDAL <code>WriteOptions</code>.</p> <code>{}</code>"},{"location":"api/operator/#opendal.Operator.open--returns","title":"Returns","text":"<pre><code>File: A file-like object that can be used to read or write the file.\n</code></pre> Example <pre><code>import opendal\n\nop = opendal.Operator(\n    \"s3\", bucket=\"bucket\", region=\"us-east-1\"\n)\nwith op.open(\"hello.txt\", \"wb\") as f:\n    f.write(b\"hello world\")\n</code></pre>"},{"location":"api/operator/#opendal.Operator.read","title":"<code>read(path, **options)</code>","text":"<p>Read the content of the object at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required <code>**options</code> <code>Any</code> <p>Optional read parameters matching the OpenDAL <code>ReadOptions</code>:</p> <ul> <li>offset (int): Byte offset to start reading from. Defaults to 0     if not specified.</li> <li>size (int): Number of bytes to read. If not specified, reads until     the end of the object.   Together, <code>offset</code> and <code>size</code> define the byte range for reading.</li> <li>version (str): Specify the version of the object to read, if     supported by the backend.</li> <li>concurrent (int): Level of concurrency for reading. Defaults to     backend-specific value.</li> <li>chunk (int): Read chunk size in bytes.</li> <li>gap (int): Minimum gap (in bytes) between chunks to consider     them separate.</li> <li>if_match (str): Read only if the ETag matches the given value.</li> <li>if_none_match (str): Read-only if the ETag does not match the     given value.</li> <li>if_modified_since (datetime): Only read if the object was modified     since this timestamp. This timestamp must be in UTC.</li> <li>if_unmodified_since (datetime): Only read if the object was not     modified since this timestamp. This timestamp must be in UTC.</li> </ul> <code>{}</code>"},{"location":"api/operator/#opendal.Operator.read--returns","title":"Returns","text":"<pre><code>bytes: The content of the object as bytes.\n</code></pre>"},{"location":"api/operator/#opendal.Operator.remove_all","title":"<code>remove_all(path)</code>","text":"<p>Convert into an async operator.</p>"},{"location":"api/operator/#opendal.Operator.rename","title":"<code>rename(source, target)</code>","text":"<p>Rename the object from source to target.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | Path</code> <p>The source path.</p> required <code>target</code> <code>str | Path</code> <p>The target path.</p> required"},{"location":"api/operator/#opendal.Operator.scan","title":"<code>scan(path, **kwargs)</code>","text":"<p>Scan the objects at the given path recursively.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the directory/ prefix.</p> required <code>**kwargs</code> <code>Any</code> <p>Optional listing parameters matching the OpenDAL <code>ListOptions</code>, excluding <code>recursive</code> which is always enforced as <code>True</code></p> <code>{}</code>"},{"location":"api/operator/#opendal.Operator.scan--returns","title":"Returns","text":"<pre><code>Iterable[Entry]: An iterable of all entries under the given path,\n    recursively traversing all subdirectories. Each entry represents\n    an object (e.g., file or directory) discovered within the full\n    descendant hierarchy of the specified path.\n</code></pre>"},{"location":"api/operator/#opendal.Operator.stat","title":"<code>stat(path, **kwargs)</code>","text":"<p>Get the metadata of the object at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required <code>**kwargs</code> <code>Any</code> <p>Optional stat parameters matching the OpenDAL <code>StatOptions</code>:</p> <ul> <li>version (str): Specify the version of the object to read, if     supported by the backend.</li> <li>if_match (str): Read only if the ETag matches the given value.</li> <li>if_none_match (str): Read-only if the ETag does not match the     given value.</li> <li>if_modified_since (datetime): Only read if the object was modified     since this timestamp. This timestamp must be in UTC.</li> <li>if_unmodified_since (datetime): Only read if the object was not     modified since this timestamp. This timestamp must be in UTC.</li> <li>cache_control (str): Override the cache-control header for the object.</li> <li>content_type (str): Explicitly set the Content-Type header for     the object.</li> <li>content_disposition (str): Sets how the object should be presented     (e.g., as an attachment).</li> </ul> <code>{}</code>"},{"location":"api/operator/#opendal.Operator.stat--returns","title":"Returns","text":"<pre><code>Metadata: The metadata of the object.\n</code></pre>"},{"location":"api/operator/#opendal.Operator.write","title":"<code>write(path, bs, **options)</code>","text":"<p>Write the content to the object at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the object.</p> required <code>bs</code> <code>bytes</code> <p>The content to write.</p> required <code>**options</code> <code>Any</code> <p>Optional write parameters matching the OpenDAL <code>WriteOptions</code>:</p> <ul> <li>append (bool): If True, append to the object instead of overwriting.</li> <li>chunk (int): Specify the chunk size in bytes for multipart uploads.</li> <li>concurrent (int): Number of concurrent upload parts. Larger values can     improve performance.</li> <li>cache_control (str): Override the cache-control header for the object.</li> <li>content_type (str): Explicitly set the Content-Type header for     the object.</li> <li>content_disposition (str): Sets how the object should be presented     (e.g., as an attachment).</li> <li>content_encoding (str): Override the Content-Encoding header.</li> <li>if_match (str): Perform the write only if the object's current     ETag matches the given one.</li> <li>if_none_match (str): Perform the write only if the object's     current ETag does NOT match the given one.</li> <li>if_not_exists (bool): Only write the object if it doesn't     already exist.</li> <li>user_metadata (dict[str, str]): Custom user metadata to associate     with the object.</li> </ul> <code>{}</code>"},{"location":"api/operator/#opendal.Operator.write--returns","title":"Returns","text":"<pre><code>None\n</code></pre>"},{"location":"api/types/","title":"Types","text":"<p>This page documents all types in OpenDAL.</p>"},{"location":"api/types/#entry","title":"Entry","text":"<p>Entry.</p> <p>An entry representing a path and its associated metadata.</p>"},{"location":"api/types/#opendal.Entry--notes","title":"Notes","text":"<p>If this entry is a directory, <code>path</code> must end with <code>/</code>. Otherwise, <code>path</code> must not end with <code>/</code>.</p>"},{"location":"api/types/#opendal.Entry.metadata","title":"<code>metadata</code>  <code>property</code>","text":"<p>The metadata of this entry.</p>"},{"location":"api/types/#opendal.Entry.name","title":"<code>name</code>  <code>property</code>","text":"<p>The name of entry, representing the last segment of the path.</p>"},{"location":"api/types/#opendal.Entry.path","title":"<code>path</code>  <code>property</code>","text":"<p>The path of entry relative to the operator's root.</p>"},{"location":"api/types/#entrymode","title":"EntryMode","text":"<p>               Bases: <code>Enum</code></p> <p>EntryMode.</p> <p>The mode of an entry, indicating if it is a file or a directory.</p> Source code in <code>python/opendal/types.pyi</code> <pre><code>@typing.final\nclass EntryMode(enum.Enum):\n    r\"\"\"\n    EntryMode.\n\n    The mode of an entry, indicating if it is a file or a directory.\n    \"\"\"\n\n    File = ...\n    r\"\"\"\n    The entry is a file and has data to read.\n    \"\"\"\n    Dir = ...\n    r\"\"\"\n    The entry is a directory and can be listed.\n    \"\"\"\n    Unknown = ...\n    r\"\"\"\n    The mode of the entry is unknown.\n    \"\"\"\n\n    def is_file(self) -&gt; builtins.bool:\n        r\"\"\"\n        Check if the entry mode is `File`.\n\n        Returns\n        -------\n        bool\n            True if the entry is a file.\n        \"\"\"\n    def is_dir(self) -&gt; builtins.bool:\n        r\"\"\"\n        Check if the entry mode is `Dir`.\n\n        Returns\n        -------\n        bool\n            True if the entry is a directory.\n        \"\"\"\n</code></pre>"},{"location":"api/types/#opendal.types.EntryMode.Dir","title":"<code>Dir = ...</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entry is a directory and can be listed.</p>"},{"location":"api/types/#opendal.types.EntryMode.File","title":"<code>File = ...</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entry is a file and has data to read.</p>"},{"location":"api/types/#opendal.types.EntryMode.Unknown","title":"<code>Unknown = ...</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The mode of the entry is unknown.</p>"},{"location":"api/types/#opendal.types.EntryMode.is_dir","title":"<code>is_dir()</code>","text":"<p>Check if the entry mode is <code>Dir</code>.</p>"},{"location":"api/types/#opendal.types.EntryMode.is_dir--returns","title":"Returns","text":"<p>bool     True if the entry is a directory.</p> Source code in <code>python/opendal/types.pyi</code> <pre><code>def is_dir(self) -&gt; builtins.bool:\n    r\"\"\"\n    Check if the entry mode is `Dir`.\n\n    Returns\n    -------\n    bool\n        True if the entry is a directory.\n    \"\"\"\n</code></pre>"},{"location":"api/types/#opendal.types.EntryMode.is_file","title":"<code>is_file()</code>","text":"<p>Check if the entry mode is <code>File</code>.</p>"},{"location":"api/types/#opendal.types.EntryMode.is_file--returns","title":"Returns","text":"<p>bool     True if the entry is a file.</p> Source code in <code>python/opendal/types.pyi</code> <pre><code>def is_file(self) -&gt; builtins.bool:\n    r\"\"\"\n    Check if the entry mode is `File`.\n\n    Returns\n    -------\n    bool\n        True if the entry is a file.\n    \"\"\"\n</code></pre>"},{"location":"api/types/#metadata","title":"Metadata","text":"<p>The metadata of an <code>Entry</code>.</p> <p>The metadata is always tied to a specific context and is not a global state. For example, two versions of the same path might have different content lengths.</p>"},{"location":"api/types/#opendal.types.Metadata--notes","title":"Notes","text":"<p>In systems that support versioning, such as AWS S3, the metadata may represent a specific version of a file. Use :attr:<code>version</code> to get the version of a file if it is available.</p>"},{"location":"api/types/#opendal.types.Metadata.content_disposition","title":"<code>content_disposition</code>  <code>property</code>","text":"<p>The content disposition of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.content_encoding","title":"<code>content_encoding</code>  <code>property</code>","text":"<p>The content encoding of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.content_length","title":"<code>content_length</code>  <code>property</code>","text":"<p>The content length of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.content_md5","title":"<code>content_md5</code>  <code>property</code>","text":"<p>The content MD5 of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.content_type","title":"<code>content_type</code>  <code>property</code>","text":"<p>The content type of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.etag","title":"<code>etag</code>  <code>property</code>","text":"<p>The ETag of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.is_dir","title":"<code>is_dir</code>  <code>property</code>","text":"<p>Whether this entry is a directory.</p>"},{"location":"api/types/#opendal.types.Metadata.is_file","title":"<code>is_file</code>  <code>property</code>","text":"<p>Whether this entry is a file.</p>"},{"location":"api/types/#opendal.types.Metadata.last_modified","title":"<code>last_modified</code>  <code>property</code>","text":"<p>The last modified timestamp of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.mode","title":"<code>mode</code>  <code>property</code>","text":"<p>The mode of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.user_metadata","title":"<code>user_metadata</code>  <code>property</code>","text":"<p>The user-defined metadata of this entry.</p>"},{"location":"api/types/#opendal.types.Metadata.version","title":"<code>version</code>  <code>property</code>","text":"<p>The version of this entry.</p>"},{"location":"examples/basic/","title":"Basic","text":"In\u00a0[\u00a0]: Copied! <pre># Install the opendal\n!pip install opendal\n</pre> # Install the opendal !pip install opendal In\u00a0[\u00a0]: Copied! <pre>import opendal\n\n# Init an operator.\nop = opendal.Operator(\"fs\", root=\"/tmp\")\nprint(f\"operator: {op}\")\n\n# Write data into object test.\nop.write(\"test\", b\"Hello, World!\")\n\n# Read data from object\nbs = op.read(\"test\")\nprint(f\"content: {bs.decode()}\")\n\n# Get object metadata.\nmeta = op.stat(\"test\")\nprint(f\"metadata: {meta}\")\n</pre> import opendal  # Init an operator. op = opendal.Operator(\"fs\", root=\"/tmp\") print(f\"operator: {op}\")  # Write data into object test. op.write(\"test\", b\"Hello, World!\")  # Read data from object bs = op.read(\"test\") print(f\"content: {bs.decode()}\")  # Get object metadata. meta = op.stat(\"test\") print(f\"metadata: {meta}\")"},{"location":"examples/pandas/","title":"Pandas","text":"In\u00a0[\u00a0]: Copied! <pre># Install the opendal and pandas\n!pip install opendal, pandas\n</pre> # Install the opendal and pandas !pip install opendal, pandas In\u00a0[\u00a0]: Copied! <pre>import pandas as pd\n\nimport opendal\n\n# Init an operator.\nop = opendal.Operator(\"fs\", root=\"/tmp\")\n\n# Create and write a csv file\nop.write(\"test.csv\", b\"name,age\\nAlice,25\\nBob,30\\nCharlie,35\")\n\n# Open and read the DataFrame from the file.\nwith op.open(\"test.csv\", mode=\"rb\") as file:\n    read_df = pd.read_csv(file)\n    print(f\"read_df: {read_df}\")\n</pre> import pandas as pd  import opendal  # Init an operator. op = opendal.Operator(\"fs\", root=\"/tmp\")  # Create and write a csv file op.write(\"test.csv\", b\"name,age\\nAlice,25\\nBob,30\\nCharlie,35\")  # Open and read the DataFrame from the file. with op.open(\"test.csv\", mode=\"rb\") as file:     read_df = pd.read_csv(file)     print(f\"read_df: {read_df}\")"},{"location":"examples/polars/","title":"Polars","text":"In\u00a0[\u00a0]: Copied! <pre># Install the opendal and polars\n!pip install opendal, polars\n</pre> # Install the opendal and polars !pip install opendal, polars In\u00a0[\u00a0]: Copied! <pre>import polars as pl\n\nimport opendal\n\n# Init an operator.\nop = opendal.Operator(\"fs\", root=\"/tmp\")\n\n# Create a DataFrame.\ndf = pl.DataFrame({\"name\": [\"Alice\", \"Bob\"], \"age\": [20, 30]})\nprint(f\"df: {df}\")\n\n# Open and write the DataFrame to the file.\nwith op.open(\"test.csv\", mode=\"wb\") as file:\n    df.write_csv(file)\n\n# Open and read the DataFrame from the file.\nwith op.open(\"test.csv\", mode=\"rb\") as file:\n    read_df = pl.read_csv(file)\n    print(f\"read_df: {read_df}\")\n</pre> import polars as pl  import opendal  # Init an operator. op = opendal.Operator(\"fs\", root=\"/tmp\")  # Create a DataFrame. df = pl.DataFrame({\"name\": [\"Alice\", \"Bob\"], \"age\": [20, 30]}) print(f\"df: {df}\")  # Open and write the DataFrame to the file. with op.open(\"test.csv\", mode=\"wb\") as file:     df.write_csv(file)  # Open and read the DataFrame from the file. with op.open(\"test.csv\", mode=\"rb\") as file:     read_df = pl.read_csv(file)     print(f\"read_df: {read_df}\")"}]}